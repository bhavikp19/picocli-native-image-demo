= Building native CLI apps in Java with picocli and GraalVM

image:https://ci.appveyor.com/api/projects/status/32r7s2skrgm9ubva?svg=true"[Appveyor Build Status,link=https://ci.appveyor.com/project/remkop/picocli-native-image-demo]
image:https://github.com/remkop/picocli-native-image-demo/workflows/Java%20CI/badge.svg[GitHub Action Build Status,link=https://github.com/remkop/picocli-native-image-demo/actions]
image:https://travis-ci.org/remkop/picocli-native-image-demo.svg?branch=master[Travis Build Status, link=https://travis-ci.org/remkop/picocli-native-image-demo]

Examples for creating GraalVM native images for picocli-based applications

CAUTION: Below is work in progress

image::https://picocli.info/images/exe-picocli-on-graalvm.png[]

== Introduction

This project shows examples of creating native images for picocli-based Java command line applications that can run as standalone executables on Windows, Linux and MacOS without requiring a JVM to be installed.

This project uses Gradle, see https://github.com/remkop/picocli-native-image-maven-demo[picocli-native-image-maven-demo] for a Maven build example.

== Artifacts

=== CheckSum

The main project builds a `checksum` executable.
This is a picocli-based command line application. 
On Windows it uses Jansi to show colors on the console and the `picocli-jansi-graalvm` library to enable the Jansi library for GraalVM native applications. 

=== HTTPS

There is also a `https` subproject that builds a `demo` native executable with `https-client` and `https-server` subcommands to demonstrate HTTPS TSL client and server applications.
The server uses a self-signed certificate. 

The https subproject also demonstrates that it is possible to build native TSL applications with GraalVM that work without the `libsunec.so` or `sunec.dll` library.

This can be achieved by specifying a `-J-Djava.security.properties=/full/path/to/java.security.overrides` option when building the native image.
The specified `java.security.overrides` file contains an entry for `security.provider.3` with a non-existing value.
This disables the SunEC elliptical curve encryption provider, which would have required the `libsunec.so` or `sunec.dll` native library.

== Windows Note

The Windows executables created with GraalVM depend on the `msvcr100.dll` native library. 
When distributing your native Windows executable you may want to include `msvcr100.dll` (from `C:\Windows\System32`) or ask your users to get it from Microsoft by installing the VS C++ Redistributable 2010.


== Testing Native Images

This project uses JUnit 5 for testing.
It has a unit test that is run before the JAR file is created, and an integration test that is run after the native image is generated.

The integration test is tagged with `@org.junit.jupiter.api.Tag("native-image")`,
and this tag is used in the Maven Surefire and Maven Failsafe plugins to ensure that only the unit tests run before the JAR is created,
and only the integration tests are run after the native image has been generated.

== Cross Compilation 

GraalVM does not have cross-compile support for native images https://github.com/oracle/graal/issues/407[yet], so at the moment you need to compile on Windows to get a Windows executable, compile on Linux to get a Linux executable, and on MacOS to get a MacOS executable. 

This project shows how to do this with a Continuous Integration setup, using GitHub Actions, AppVeyor and TravisCI.
The current setup creates Linux and MacOS executables with GitHub Actions, and a Windows executable on AppVeyor and TravisCI. 

== Install Compiler Toolchain

The setup for your Continuous Integration environment needs to have a JDK, and the toolchain to compile C/C++ code.

=== Linux and MacOS Compiler Toolchain

For compilation `native-image` depends on the local toolchain, so on Linux and MacOS we need `glibc-devel`, `zlib-devel` (header files for the C library and zlib) and `gcc` to be available on our system. The below is not required with GitHub Actions, since these are already available:

On Linux: `sudo dnf install gcc glibc-devel zlib-devel` or `sudo apt-get install build-essential libz-dev`.

On macOS, execute `xcode-select --install`.

=== Windows Compiler Toolchain

GraalVM https://github.com/oracle/graal/issues/1258[needs] the https://www.microsoft.com/en-us/download/details.aspx?id=8442[Microsoft Windows SDK for Windows 7 and .NET Framework 4] as well as the https://stackoverflow.com/a/45784634/873282[C compilers from KB2519277].

You can install these using https://chocolatey.org/docs/installation[chocolatey]:

----
choco install windows-sdk-7.1 kb2519277
----

Then (from the `cmd` prompt), activate the sdk-7.1 environment:

----
call "C:\Program Files\Microsoft SDKs\Windows\v7.1\Bin\SetEnv.cmd"
----

This starts a new Command Prompt, with the sdk-7.1 environment enabled. All subsequent commands must be run in this Command Prompt window.



== Gradle

The Gradle build uses the wonderful https://github.com/palantir/gradle-graal[gradle-graal plugin] from Palantir. This plugin will download the GraalVM JDK and unzip it and build with that. 

The plugin has https://github.com/palantir/gradle-graal/pull/127[support for Windows], and it will take care of calling `call "C:\Program Files\Microsoft SDKs\Windows\v7.1\Bin\SetEnv.cmd"` to ensure the windows-sdk-7.1 environment is set up before the `native-image` generation tool is invoked.

This makes your Gradle setup very simple. See the project https://github.com/remkop/picocli-native-image-demo/blob/master/build.gradle[build.gradle].


